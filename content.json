[{"title":"Java并发控制","date":"2017-05-12T14:10:55.000Z","path":"2017/05/12/java并发控制/","text":"Java并发控制这几天遇到一个业务需要使用java锁，由此对java锁进行了学习。在此对这几天的学习和心得做一个总结。 从业务说起送单模块中有一个预存扣款业务，该业务先从数据库通过房屋ID取出房屋的预存信息，如果有预存则判断预存金额是否大于订单金额，如果是则进行预存扣款。 先看一下这段业务代码: 12345678910111213141516171819202122/** * 预存扣款 * * @param houseUuid 房屋id * @param price 待扣款金额 * @return 扣款结果 */private boolean storeCharge(String houseUuid, BigDecimal price) &#123; //查找房屋预存信息 final HouseAmount houseAmount = houseAmountDao.selectByHouseId(houseUuid); if (houseAmount == null) &#123; return false; //如果房屋没有房屋金额记录，返回False &#125; final BigDecimal prestoreAmount = houseAmount.getPrestoreAmount(); if (prestoreAmount == null || prestoreAmount.compareTo(price) != 1) &#123; return false;//如果预存金额为空，或者预存金额小于待扣款金额，返回False &#125; final BigDecimal balance = prestoreAmount.subtract(price);//预存金额减去待扣款金额 houseAmount.setPrestoreAmount(balance); houseAmountDao.updateByHouseSelective(houseAmount); //更新预存信息 return true;&#125; ###冲突 考虑送单模块是从rabbitmq中获取账单信息，并且是多线程和可以分布式部署的，会存在一种情况，就是持有相同房屋ID的两个线程同时处理预存扣款业务，引发以下冲突: 丢失更新：一个事务的更新覆盖了其它事务的更新结果，就是所谓的更新丢失。例如：线程A把预存金额从6改为2，线程B把预存金额从6改为3，则线程A丢失了他的更新。 脏读：当一个事务读取其它完成一半事务的记录时，就会发生脏读取。例如：线程A,B看到的预存金额都是6，线程B把预存金额改为2，线程A读到的预存金额仍为6。 为了解决这些并发带来的问题。 我在代码中引入并发控制。这个过程中经历了一下几个阶段: ###synchronized 我在第一时间想到的是使用synchronized关键字。java中当synchronized用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。修改后的代码变成这样 123456789101112131415161718192021222324/** * 预存扣款 * * @param houseUuid 房屋id * @param price 待扣款金额 * @return 扣款结果 */private boolean storeCharge(String houseUuid, BigDecimal price) &#123; synchronized (houseUuid.intern()) &#123; //使用HouseUuid为锁信息 //查找房屋预存信息 final HouseAmount houseAmount = houseAmountDao.selectByHouseId(houseUuid); if (houseAmount == null) &#123; return false; //如果房屋没有房屋金额记录，返回False &#125; final BigDecimal prestoreAmount = houseAmount.getPrestoreAmount(); if (prestoreAmount == null || prestoreAmount.compareTo(price) != 1) &#123; return false;//如果预存金额为空，或者预存金额小于待扣款金额，返回False &#125; final BigDecimal balance = prestoreAmount.subtract(price);//预存金额减去待扣款金额 houseAmount.setPrestoreAmount(balance); houseAmountDao.updateByHouseSelective(houseAmount); //更新预存信息 return true; &#125;&#125; 考虑到只有houseUuid相同时才会引起冲突，使用houseUuid为锁信息，这样当线程之间持有不同houseUuid时，是不会进行并发控制的，解决冲突的同时还保证了代码执行的效率。完美!!! 但是我忽略了一个问题，计费模块是可以分布式部署的，在单应用情况下，这种方式是完美的，在多应用的情况下，这种方式显然是不可行的。synchronized的锁信息只有本应用内的线程还可以观察到，应用之间是无法知道其他应用的锁信息的。怎么办？使用分布式锁。 分布式锁什么事分布式锁，分布式锁是控制分布式系统之间同步访问共享资源的一种方式。通过分布式锁，应用之间就可以知道一个houseUuid是否被上锁了，帮助我们解决分布式部署的应用之间并发控制的问题。 目前实现分布式锁主流的方式有三种: 使用zookeeper 使用memcached 使用redis 这三种方式在网络上都能找到很多的示例。考虑到我们系统中使用了zookeeper和redis以及三种方式的优缺点， 最终使用的是基于redis的分布式锁方案。使用分布式锁后代码变成如下: 12345678910111213141516171819202122232425262728293031323334353637/** * 预存扣款 * * @param houseUuid 房屋id * @param price 待扣款金额 * @return 扣款结果 */private boolean storeCharge(String houseUuid, BigDecimal price) &#123; RLock lock = null; final String key = \"storeCharge:\" + houseUuid;//key信息 try &#123; lock = RedisUtils.getRLock(redissonClient, lockKey);//获取key的锁信息 if (lock != null) &#123;//获得锁成功 //设置线程等待时间，最大持锁时间，单位 Boolean status = lock.tryLock(waitTime, leaseTime, timeUnit); if (status) &#123; //上锁成功 //查找房屋预存信息 final HouseAmount houseAmount = houseAmountDao.selectByHouseId(houseUuid); if (houseAmount == null) &#123; return false; //如果房屋没有房屋金额记录，返回False &#125; final BigDecimal prestoreAmount = houseAmount.getPrestoreAmount(); if (prestoreAmount == null || prestoreAmount.compareTo(price) != 1) &#123; return false;//如果预存金额为空，或者预存金额小于待扣款金额，返回False &#125; final BigDecimal balance = prestoreAmount.subtract(price);//预存金额减待扣款金额 houseAmount.setPrestoreAmount(balance); houseAmountDao.updateByHouseId(houseAmount); //更新预存信息 return true; &#125; &#125; &#125; finally &#123; if (lock != null) &#123; lock.unlock(); &#125; &#125;&#125; 分布式锁的原理可以看做是把key的锁信息保存在redis上，线程执行到该段业务的时候就先去redis查询对应key是否被上锁，为了防止死锁，redis分布式锁可以设置线程最大等待时间和线程持锁时间。线程超过最大等待时间的如果还无法获取，则直接失败，线程退出。线程如果持锁超过线程持锁时间，线程释放锁信息，线程继续执行。分布式锁非常完美帮助我们做到synchronized不能解决的问题，同时还是保证了代码执行的效率。非常完美!!! 但是仔细推敲下，还会存在问题。分布式锁为了解决死锁问题，设置了最大持锁时间。考虑一种情况，持有相同houseUuid的线程A和线程B同时处理该业务，线程A成功拿到锁进入业务流程处理业务，线程B处于等待状态。线程A获取到房屋预存金额为100元，不幸的是获取后线程卡住了，并且超过了最大持锁时间。此时，锁被释放，线程B开始处理业务，但是因为线程A还没有更新预存信息，线程A和线程B此时拿到的房屋预存信息的预存金额是一样的，都是100元，线程B成功处理业务扣款20并成功更新了预存金额为80，此时数据库的值为80。但是虽然线程A释放了锁，但是线程A并没有死亡，在线程B执行成功后，线程A恢复了，成功处理业务扣款10并成功更新了预存金额为90，此时数据库的值为90，发生了丢失更新的情况。 分布式锁仍然不完美，在更新预存信息的时候仍然会发生冲突。那么有没有办法在update的时候也进行并发控制的呢？有的，我们可以使用乐观锁或悲观锁 乐观锁和悲观锁 悲观锁：每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。悲观锁比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。 乐观锁：每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。乐观锁比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。乐观锁的实现 1、使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。 2、乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。 乐观锁执行过程12345//第一步，查出数据信息SELECT (status, version) FROM items where id=&#123;#id&#125;;//第二步，根据商品信息生成订单//第三步，修改商品status为2UPDATE items SET status=2, version=version+1 WHERE id=#&#123;id&#125; AND version=#&#123;version&#125;; 悲观锁的实现悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。 使用乐观锁悲观锁的实现需要修改mysql的设置且实现过程较为复杂。且目前表中多有含义为更新时间的字段(update_ts或modifyTime)，每次数据更新时数据都会自动更新，方便使用乐观锁。所以最终使用的乐观锁。使用乐观锁对sql语句进行如下修改: 修改前: 1234567891011121314&lt;update id=&quot;updateByHouseId&quot; parameterType=&quot;com.chargeProject.consumer.entity.HouseAmount&quot;&gt; update house_amount set community_id = #&#123;communityId,jdbcType=VARCHAR&#125;, community_name = #&#123;communityName,jdbcType=VARCHAR&#125;, house_id = #&#123;houseId,jdbcType=VARCHAR&#125;, house_name = #&#123;houseName,jdbcType=VARCHAR&#125;, houseowner_id = #&#123;houseownerId,jdbcType=VARCHAR&#125;, houseowner_name = #&#123;houseownerName,jdbcType=VARCHAR&#125;, arrears_amount = #&#123;arrearsAmount,jdbcType=DECIMAL&#125;, deposit_amount = #&#123;depositAmount,jdbcType=DECIMAL&#125;, prestore_amount = #&#123;prestoreAmount,jdbcType=DECIMAL&#125;, crop_id = #&#123;cropId,jdbcType=VARCHAR&#125; where house_id = #&#123;houseUuid,jdbcType=VARCHAR&#125; //更新条件为id &lt;/update&gt; 修改后: 123456789101112131415&lt;update id=&quot;updateByHouseId&quot; parameterType=&quot;com.chargeProject.consumer.entity.HouseAmount&quot;&gt; update house_amount set community_id = #&#123;communityId,jdbcType=VARCHAR&#125;, community_name = #&#123;communityName,jdbcType=VARCHAR&#125;, house_id = #&#123;houseId,jdbcType=VARCHAR&#125;, house_name = #&#123;houseName,jdbcType=VARCHAR&#125;, houseowner_id = #&#123;houseownerId,jdbcType=VARCHAR&#125;, houseowner_name = #&#123;houseownerName,jdbcType=VARCHAR&#125;, arrears_amount = #&#123;arrearsAmount,jdbcType=DECIMAL&#125;, deposit_amount = #&#123;depositAmount,jdbcType=DECIMAL&#125;, prestore_amount = #&#123;prestoreAmount,jdbcType=DECIMAL&#125;, crop_id = #&#123;cropId,jdbcType=VARCHAR&#125; //注意，更新时不需要传入update_ts值，该值数据库会自动更新，手动传入update_ts值反而有可能导致并发控制失败 where house_id = #&#123;houseUuid,jdbcType=VARCHAR&#125; AND update_ts = #&#123;updateTs,jdbcType=TIMESTAMP&#125; //更新条件增加update_ts &lt;/update&gt; 修改后的更新语句新增了update_ts验证，只要数据更新成功update_ts就会被更新。解决了分布式锁线程恢复时可能会导致丢失更新的冲突。在使用乐观锁后，业务代码修改为: 12345678910111213141516171819202122/** * 预存扣款 * * @param houseUuid 房屋id * @param price 待扣款金额 * @return 扣款结果 */private boolean storeCharge(String houseUuid, BigDecimal price) &#123; //查找房屋预存信息 final HouseAmount houseAmount = houseAmountDao.selectByHouseId(houseUuid); if (houseAmount == null) &#123; return false; //如果房屋没有房屋金额记录，返回False &#125; final BigDecimal prestoreAmount = houseAmount.getPrestoreAmount(); if (prestoreAmount == null || prestoreAmount.compareTo(price) != 1) &#123; return false;//如果预存金额为空，或者预存金额小于待扣款金额，返回False &#125; final BigDecimal balance = prestoreAmount.subtract(price);//预存金额减去待扣款金额 houseAmount.setPrestoreAmount(balance); houseAmountDao.updateByHouseSelective(houseAmount); //更新预存信息 return true;&#125; 使用乐观锁后，代码和最先的一样，抛弃了synchronized和分布式锁，但是却不会发生并发问题，可以说是简单粗暴的方式。但是乐观锁不适用于写入非常频繁的操作，比如该业务，如果有10个线程同时进来，一个线程更新成功后，其他9个就会报失败，并发量越高，请求失败几率越大。同时为了确保每次获取到的信息都是准确的，同时避免丢失更新的问题。最终采用的是java并发锁和乐观锁一起使用的方式。 乐观锁和分布式锁解决了分布式部署之间多个应用的并发问题，但是他们都有一个不足。这两种并发控制都需要在代码层进行控制。而在微服务下，通常都是好几个应用共享一个微服务，应用A进行了并发控制，应用B没有进行并发控制，这时候仍然会存在并发问题。而要解决这个问题，就可以使用悲观锁，悲观锁是数据库层面的锁，对于数据库的操作最终都是由数据库进行，使用悲观锁能够很好的解决了乐观锁的问题。与乐观锁相反，悲观锁适用于写操作比较多的业务。如果是读比较多的业务，每次读取数据都要排队，那就很蛋疼了。在目前的互联网情况下，大多使用的是乐观锁，绝大部分场景下，乐观锁都能满足要求，而且效率也比较高。 参考资料： 分布式锁的实现方式一分钟教你知道乐观锁和悲观锁的区别乐观锁与悲观锁——解决并发问题悲观锁和乐观锁的区别和应用场景使用乐观锁实现商城秒杀","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"},{"name":"锁","slug":"锁","permalink":"http://yoursite.com/tags/锁/"}]},{"title":"SpringBoot使用JRebel实现热部署","date":"2017-03-26T15:43:31.000Z","path":"2017/03/26/SpringBoot使用JRebel实现热部署/","text":"为什么要热部署在进行SpringBoot项目开发时，每次修改类后，都需要重启项目才能对所做的修改进行调试，使用热部署工具，可以无需重启服务，节约时间。 IntelliJ Idea 使用JRebel实现热部署一、安装JRebel1、在Idea插件仓库搜索下载并安装 jrebel 6.5.2。安装完成后需要重启idea，重启完成后关闭idea2、下载破解补丁3、解压缩破解补丁(该补丁在mac下为的文件夹名称为.jrebel，mac不会显示，可以在控制台使用ll命令查看解压是否成功！)4、使用mv命令替换.jrebel。mv -r ‘破解文件解压地址’ /Users/用户名/.jrebel。替换完成后破解成功。 二、使用JRebel1、在需要进行热部署的模块点击右键-&gt;JRebel-&gt;rebel.xml，如下图完成后会在resources文件夹下生成rebel.xml文件，如下图2、使用JRebel插件运行SpringBoot项目，如下图或者点击右上角的使用JRebel运行项目按钮，如下图运行时出现以下画面，则使用JRebel热部署插件运行成功3、在编辑保存完.java文件时只要在修改的文件上点击右键，选择重编译文件&lt;如下图&gt;，就可以享受热部署带来的快感，无需重启就可以调试修改后的代码了 三、实现实时编译，方便JRebel保存即自动编译在之前的操作中，每次保存完，我们都需要手动点击重编译。能不能一步到位，保存的时候就重编译呢。我们可以使用idea的宏编辑来实现这一功能。1、选择Edit -&gt; Macros -&gt; Start Macro Recording2、打开一个java文件3、按Ctrl+S键4、按Command+Shift+F9键5、选择Edit -&gt; Macros -&gt; Stop Macro Recording，在弹出框中输入“Save &amp; Compile”6、选择IntelliJ Idea -&gt; Preferences -&gt; Keymap,在搜索框中输入“Save &amp; Compile”，选中“Mocros”下的“Save &amp; Compile”,右键选择“Add Keyboard Shortcut”,按Ctrl+S键，点击“OK”，之后点击“Remove”","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"Jrebel","slug":"Jrebel","permalink":"http://yoursite.com/tags/Jrebel/"},{"name":"热部署","slug":"热部署","permalink":"http://yoursite.com/tags/热部署/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]